To illustrate our profile language, we present an example
profile in Figure 1. Observe that the profile specification is
broken into two parts: the Domain clause (DOMAIN) defines
and names sets of objects of interest (domain sets);
and the Utility clause (UTILITY) specifies the relative values
of objects contained in each domain set. The Utility
clause distinguishes our notion of profiles from those typically
found in publish/subscribe systems. We will explain
the intuitive meaning of these profiles here as an informal
means of introducing our profile language. A complete formal
semantics of our profile language can be found in [10].
Profile Traveler might be used to drive data recharging
for a traveler about to travel to Boston. Suppose the
traveler wants to stay downtown. She needs to get from the
airport to a downtown hotel, either by rental car or a shuttle.
For a shuttle, she needs a schedule for a company offering
shuttle service. For a rental car, she needs rate information
for one or more rental car companies and driving directions
from the airport to downtown. Even if she takes a shuttle
downtown, directions serve some use as they tell her a bit
about how to get about the city. She also needs information
about downtown hotels, but only if she has received a
shuttle schedule or directions telling her how to get to them
Finally, she would like to see reviews for nearby restaurants.
The Domain clause of Traveler identifies 5 domain
sets specified by expressions resembling inputs to a search
engine.2 As with a query, declarative specifications of domain
sets free profile authors from having to locate the data
that interests them (the traveler may not care whether directions
to a downtown hotel are generated by Mapquest [16]
or found on a hotel web page), and makes the profile processor
responsible for finding this data. In this profile, RC is a
set of rental car company web pages that (presumably) offer
details about rates and policies, Sh is a set of shuttle schedules
for shuttles heading to downtown from the airport, Di
is a set of web pages, text files etc. that give directions from
the airport to downtown, Ho is a set of web pages for hotels
located in downtown Boston, and Re is a set of reviews
for restaurants also located in downtown Boston. The Utility
clause of Traveler specifies 5 utility ‚Äúequations‚Äù (one
for each domain set) that capture the data values and dependencies
previously described. Every restaurant review has a
value of 1. The value of rental car web pages (RC objects) is
dependent on the presence of Di objects in the same cache:
the condition, ‚Äú[#Di  0]‚Äù, is true if the number of Di
objects in the cache (#Di) is greater than 0. This reflects
the dependency of the value of rental car data on having
driving directions. The value of RC objects also depends on
how many of them appear in the cache. ‚ÄúUPTO (2, 2,
0)‚Äù specifies that the first two RC objects in the cache carry
a value of 2, and that any more found in the cache have no
value. This reflects the preference that having 2 rental car
web pages in the cache is useful (so that rates and policies
can be compared), but that any more than this is unnecessary.
UPTO 	
 is a threshold operator: up to  objects
have a value of  each, and every object beyond  has
a value of 
 . Sh, Di and Ho objects are defined similarly to
RC objects: up to 1 shuttle schedule has value 3; up to 1 set
of directions to downtown has value 1 provided that a hotel
web page is in the cache; and up to 1 hotel web page has
value 2, provided that either a set of directions or a shuttle
schedule are also in the cache. Thus a cache consisting of
two rental car web pages, one set of directions and a hotel
web page would have overall value of  (), and
a cache consisting of one shuttle schedule, one rental car
web page and two restaurant reviews would have an overall
cache value of().
The Traveler profile demonstrates two desirable features
of profile languages: data dependencies and thresholds.
In Figure 2 we show three ways that Traveler
might be expressed in a profile language lacking these features.
T sets utility values for each domain equal to their
initial value in Traveler. T values domains according
to a ranking of the maximum values that those domains can
take according to Traveler. For example, Sh is the most
valuable domain (as an object in Sh can have value 3), and
therefore is given the highest value of 5. Finally, T clusters
dependent objects in Traveler into single conglomerate
objects. As dependencies exist between Ho, Sh, Di and
RC, they are combined into a single domain of megaobjects,
with the idea that an object of one simple domain (e.g., Ho)
can only be placed in the cache if it is accompanied by an
object of each other domain in the conglomeration. The size
and value of these megaobjects is their combined size and
value according to Traveler.
Table 1 shows the optimally valued cache of 5 objects
according to the Traveler profile of Figure 1 and the
three alternative profiles of Figure 2, and the ‚Äúreal‚Äù values
of these caches according to the Traveler profile that
includes dependencies and thresholds. Observe that both
T and T would fill 5 object caches with what they assess
to be the most valuable objects (shuttle schedules), leaving
both caches with a real overall value of 3. Both profiles
fail to produce a better cache because they are unaware of
the threshold that limits the number of shuttle schedules that
have value. Even if T had ranked Re with the highest ranking
(restaurant reviews are the only objects that have value
no matter how many of them are placed in the cache), the
value of its 5 object caches would only be 5. T‚Äôs strategy
of clustering dependent objects into a single conglomerate
object works reasonably well for a 5 object cache, but note
that this approach can never result in a cache with differing
numbers of Ho, Di, Sh and RC objects, as is needed to produce
the optimally valued cache (which has 2 RC objects,
and no more than 1 of any other).
Data dependencies and thresholds are just some of the
desirable features defined in our profile language. Other
features demonstrated by the Traveler profile include the
separate specifications of the objects of interest, and the relative
worth of these objects, and QoS-style weighted utility
values (as opposed to priority lists). This list is not exhaustive;
a comprehensive list of profile language desiderata is
presented elsewhere [9], as is a formal specification of our
profile language framework [10].
In practice, we expect profiles to describe many more domain
sets with more complex utility value expressions than
was demonstrated with the Traveler profile. We consider
it unlikely that most users will write profiles manually
(the same could be said for SQL). Instead, we expect that
a profile-generation system [7] with good interfaces could
support users to this end. Such a system could rely on libraries
of parameterized profiles that are built and extended
by experts. The key idea is that a declarative profile language
is needed to facilitate this process. Finally, we recognize
that profile-driven cache management will have to
reconcile the data needs of thousands of users, as specified
with thousands of profiles. We consider techniques for processing
multiple profiles in Section 3.3.