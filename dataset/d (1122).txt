Aurora contains built-in support for eight primitive operations for expressing its stream processing requirements. Included among these are windowed operators that operate on sets of consecutive tuples from a stream ("windows") at a time. Every windowed operator applies an input (user-defined) function to a window and then advances the window to capture a new set of tuples before repeating the processing cycle. Slide advances a window by "sliding" it downstream by some number of tuples. This operator could be used to perform rolling computations, as in a query that continuously determines the average value of IBM stock over the most recent three hours. Tumble resembles Slide except that consecutive windows have no tuples in common. Rather, Tumble effectively partitions a stream into disjoint windows. This is useful, for example, when calculating daily stock indexes, where every stock quote is used in exactly one index calculation. Latch resembles Tumble but can maintain internal state between window calculations. This is useful for "infinite window" calculations, such as one that maintains the maximum or average value of every stock, maintained over its lifetime. Finally, Resample produces a partially synthetic stream by interpolating tuples between actual tuples of an input stream.
Aside from Aurora's windowed operations are operators that act on a single tuple at a time. The Filter operator screens tuples in a stream for those that satisfy some input predicate. A special case of Filter is Drop, which drops random tuples at some rate specified as an operator input. Map applies an input function to every tuple in a stream. GroupBy partitions tuples across multiple streams into new streams whose tuples contain the same values over some input set of attributes. Finally, Join pairs tuples from input streams whose "distance" (e.g., difference in timestamps) falls within some given upper bound. For example, this distance might be set to 30 minutes if one wanted to pair stocks whose prices coincide within a half-hour of each other.
Other desirable idioms for stream processing can be expressed as compositions of Aurora's built-in primitives. For example, while Aurora has no built-in "CASE statement" operator, one can be simulated by first applying a Map operator to a stream (that assigns a value to a new attribute that is dependent on which case predicate is satisfied) and then using GroupBy to partition tuples according to values assigned to this attribute. Additionally, there is no explicit Split box; instead a query can connect the output of one box to the inputs of several others.
A full treatment of these operators is beyond the scope of this paper.