For the opportunistic aggregation, the sink initially diffuses an interest for a low event-rate notification (i.e., an
exploratory event) intended for path establishment and repair. We call the gradients set up for sending exploratoryevents exploratory gradients. Once a source detects a matching target, it sends exploratory events, possibly along
multiple paths, toward the sink. After the sink receives these exploratory events, it reinforces one particular neighbor
in order to “draw down” real data (i.e., events at a higher data rate that allow high quality tracking of targets). We
call the gradients set up for sending high quality tracking events data gradients. The local rule for selecting an
empirically low delay path is to reinforce any neighbor from which a node recieves a previously unseen exploratory
event.
For our greedy aggregation, each event contains an additional attribute , the energy cost for delivering this
event from the source to the current node. Once a source detects phenomena, it sends exploratory events with   
to each neighbor for whom it has a gradient. After a node receives these previously unseen exploratory events,
it adds the cost of that transmission to  before resending. Since our radios have fixed transmission power, we
measure energy as equivalent to hops, but direct measures of variable energy could also be used. Although this
energy attribute is useful for selecting a lowest-energy path, it is not sufficient for constructing a greedy incremental
tree because there is no path-sharing information.
To provide such information, each source on the existing tree (i.e., a source with data gradients) also generates an
incremental cost message, once it receives a previously unseen exploratory message generated by other sources. The
incremental cost message contains the random message id of the corresponding exploratory event and the additional
energy cost  required for delivering that exploratory event to the existing tree. This incremental cost message is
only sent along the existing tree using data gradients. Unlike the energy cost , the incremental energy cost  can
only be decreased (in order to find the closest point on the existing tree). Once an on-tree node receives a previously
unseen incremental cost message, it searches for the corresponding exploratory event in its message cache. The
node updates  of the incremental cost message to the minimum value between the current  and the energy cost
 of the exploratory event retrieved from the cache, before sending the incremental cost message to its outgoing
data gradients.
Once a sink receives a previously unseen exploratory event, it does not reinforce a neighbor immediately because
an energy-efficient path is not necessarily a lowest-delay path. Instead, a reinforcement timer of  is set up. After
the timer expires, the sink reinforces any neighboring node that sent the exploratory event or the incremental cost
message (of the corresponding exploratory event) at the lowest energy cost. If the energy cost of an exploratory event
and the incremental cost message are equivalent, the sink reinforces the neigbhoring node that sent the exploratory
event. Other ties are decided in favor of the lowest delay. When the neighboring node receives the reinforcement
message (associated with the random message id of the exploratory message), the node sets a data gradient towards
the sink (or the node that sends the reinforcement) and reinforces an upstream neighboring node immediately using
the above local rule without setting up a timer.
As a result, a greedy incremental tree can be constructed using the described local rule (See Figure 3 for example).
Unlike the exploratory event, the incremental cost message contains the minimum energy cost of delivering
data from a new source to the existing tree (not to the sink). The path from the first source to the sink is a lowest
energy path because of no existing tree or no incremental cost message genearted yet. Each subsequent source is
incrementally connected to the aggregation tree at the closest point (using the energy cost information provided by
the incremental cost message). Hence, one might wonder if this algorithm requires unsynchronized sources so that
each source can be incrementally connected to the tree. We do not make that assumption because sources can besynchronized if they are triggered by the same phoenomena. Although we have described the algorithm using examples
in which different sources start at different times, the algorithm in fact works when sources start transmitting
events in near simultaneity. In that scenario, the algorithm initially constructs a lowest-energy-path tree (i.e., each
source is connected to the sink using the lowest-energy path), but this problem is not persistent. At the subsequent
round of exploratory events, the greedy incremental tree will be constructed and the lowest-energy-path tree will be
pruned off using the negative reinforcement mechanism in Section 4.3.