The algorithm described in Section 4.1 can result in more than one path being reinforced after multiple rounds of exploratory events (due to synchronized sources and network dynamics). For energy efficiency, we need a mechanism to negatively reinforce (to truncate) unnecessary or inefficient paths. To find the inefficient paths, our trucation rule might also need to compute the set cover. Given that different neighbors might report aggregates of different subsets of data items, with varying costs, the challenge is to find the set of neighbors who cover the data items at the smallest cost. A simple truncation rule is to negatively reinforce neighbors that are not in the set cover.
Specifically, one plausible choice for a truncation rule is to negatively reinforce neighbors from which no energyefficent aggregates have been received within a window of  events or time . The local rule we evaluate in Section 5 is based on a time window of , chosen to be 2 seconds in our simulations (or 4 times of the aggregation delay ). An incoming aggregate is considered energy-efficient if it is selected as a subset in the set cover .For example (Figure 4(a)), node L will negatively reinforce node K because is not in. However, given that events and are generated by sources and , respectively, this direct approach is a bit conservative and energy inefficient (G will likely send in its next aggregate. Therefore, H should also be negatively reinforced).Our more energy-efficient rule is to compute the set cover  of sources not events. To do this, each event in an aggregate is replaced by its source. To preserve the initial cost ratio, the new associated energy cost of the transformed aggregate is. For example, the subsets of events in Figure 4(a) can be transforme to the subsets of sources in Figure 4(b). After the transformation,and whereas and. The cost ratios are still and.Using the greedy heuristic,is selected as the only subset in. Therefore, L negatively reinforces H and K.When H receives this negative reinforcement, it degrades its gradient towards L (from a data gradient to an exploratory gradient). Furthermore, if all its gradients are now exploratory, H negatively reinforces those neighbors that have been sending data to it (as opposed to exploratory events). This sequence of local interactions ensures that
the path through H is degraded rapidly.