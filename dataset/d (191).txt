TAG consists of two phases: a distribution phase, in which aggregate queries are pushed down into the network, and a collection phase, where the aggregate values are continually routed up from children to parents. Recall that our query semantics partition time into epochs of duration, and that we must produce a single aggregate value (when not grouping) that combines the readings of all devices in the network during that epoch.
Given our goal of using as few messages as possible, the collection phase must ensure that parents in the routing tree wait until they have heard from their children before propagating an aggregate value for the current epoch. We will accomplish this by having parents subdivide the epoch such that children are required to deliver their partial state records during a parent-specfied time interval. This interval is selected such that there is enough time for the parent to combine partial state records and propagate its own record to its parent.
When a mote p receives a request to aggregate,p, either from another mote or from the user, it awakens, synchronizes its clock according to timing informationin the message, and preparesto participate in aggregation. In the tree based routing scheme,pchooses the sender of the message as its parent. In addition to the information in the query,pincludes the interval when the sender is expecting to hear partial state records from p.pthen forwards the query requestdown the network, setting this delivery interval for children to be slightly before the time its parent expects to see p’s partial state record. In the tree-based approach, this forwarding consists of a broadcast of r, to include any nodes that did not hear the previous round, and include them as children (if it has any.) These nodes continue to forward the request in this manner, until the query has been propagated throughout the network.
During the epoch after query propagation, each mote listens for messages from its children during the interval it specfied when forwarding the query. It then computes a partial state record consisting of the combination of any child values it heard with its own local sensor readings. Finally, during the transmission interval requested by its parent, the mote transmits this partial state record up the network. Figure 1 illustrates the process. Notice that parents listen for longer than the transmission interval they
specified, to overcome limitations in the quality of clock synchronization algorithms between parents and children. In this way, aggregates flow back up the tree interval-byinterval. Eventually, a complete aggregate arrives at the root. During each subsequent epoch, a new aggregate is produced. Notice that, for a significant portion of each epoch, motes are idle and can enter a low power state.
This scheme begs the question of how parents choose the duration of the interval in which they will receive values. It needs to be long enough such that all of a node’s children can report, but not so long that the epoch ends before nodes deep in the tree can schedule their communication. Furthermore, longer intervals require radios to be powered up for more time, which consumes precious energy. In general, the proper choice of duration for these intervals is somewhat environment speci?c, as it depends on the density of radio cells and “bushiness” of the network topology. For the purposes of the simulations and experiments in this paper, we assume the network has a maximum depth d, and set the duration of each interval to be (EPOCH DURATION)/d, with nodes at leveltrans i mitting during the ithinterval. We rely on the TinyOS MAC layer [32] to avoid collisions between nodes transmitting during the same interval. Note that this provides a lower-bound on the EPOCH DURATION and constrains the maximum sample rate of the network, since the epoch must be long enough for partial state records from the bottom of the tree to propagate to the root.
To increase the sample rate, one could consider pipelining the communications schedule shown in Figure 1. With pipelining, the output of the network would be delayed by one or more epochs, as some nodes would wait until the next epoch to report the aggregates they collected during the current epoch. In exchange for such delays, the effective sample rate of the system is increased (for the same reason that pipelining a long processor stage increases the clock rate of a CPU.) We do not consider such schemes
in detail here; we discussed a fully-pipelined approach to aggregation in a workshop submission [20].
In Section 5.1 we show how TAG can provide an order of magnitude decrease in communications costs over a centralized approach. However, before discussing performance, we extend the approach to support grouping.