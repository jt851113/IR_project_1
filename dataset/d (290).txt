The widespread deployment of sensors is transforming the physical world into a computing platform.  Modern sensors not only respond to physical signals to produce data, they also embed computing and communication capabilities. They are thus able to store, process locally and transfer the data they produce. Still, at the heart of each sensor, a set of signal processing functions transform physical signals such as heat, light, sound, pressure, magnetism, or a particular motion into sensor data, i.e., measurements of physical phenomena as well as detection, classification or tracking of physical objects. Applications monitor the physical world by querying and analyzing sensor data. Examples of monitoring applications include supervising items in a factory warehouse, gathering information in a disaster area, or organizing vehicle traffic in a large city [6]. Typically, these applications involve a combination of stored data (a list of sensors and their related attributes, such as their location) and sensor data. We call these sensor databases. This paper focuses on sensor query processing – the design, algorithms, and implementations used to run queries over sensor databases. The concepts developed in this paper were developed under the DARPA Sensor Information Technology (SensIT) program [22].  We define a sensor query as a query expressed over a sensor database. A typical monitoring scenario involves aggregate queries or correlation queries that give a bird’s eye view of the environment as well as queries zooming on a particular region of interest. Representative sensor queries are given below in Example 1.  Example 1 (Factory Warehouse): Each item of a factory warehouse has a stick-on temperature sensor attached to it. Sensors are also attached to walls and embedded in floors and ceilings. Each sensor provides two signal-processing functions: (a) getTemperature() returns the measured temperature at regular intervals, and (b) detectAlarmTemperature(threshold) returns the temperature whenever it crosses a certain threshold. Each sensor is able to communicate this data and/or to store it locally. The sensor database stores the identifier of all sensors in the warehouse together with their location and is connected to the sensor network. The warehouse manager uses the sensor database to make sure that items do not overheat. Typical queries that are run continuously include: ? Query 1: “Return repeatedly the abnormal temperatures measured by all sensors.” ? Query 2: “Every minute, return the temperature measured by all sensors on the third floor”. ? Query 3: “Generate a notification whenever two sensors within 5 yards of each other simultaneously measure an abnormal temperature”.  ? Query 4: “Every five minutes retrieve the maximum temperature measured over the last five minutes”. ? Query 5: “Return the average temperature measured on each floor over the last 10 minutes”.  These example queries have the following characteristics: ‧ Monitoring queries are long running. ‧ The desired result of a query is typically a series of notifications of system activity (periodic or triggered by special situations). ‧ Queries need to correlate data produced simultaneously by different sensors. ‧ Queries need to aggregate sensor data over time windows. ‧ Most queries contain some condition restricting the set of sensors that are involved (usually geographical conditions). As in relational databases, queries are easiest to express at the logical level. Queries are formulated regardless of the physical structure or the organization of the sensor network. The actual structure and population of a sensor network may vary over the lifespan of a query. Clearly, there are similarities with relational database query processing. Indeed, most applications combine sensor data with stored data. However, the features of sensor queries described here do not lend themselves to easy mapping to relational databases and sensor data is different from traditional relational data (since it is not stored in a database server and it varies over time). There are two approaches for processing sensor queries: the warehousing approach and the distributed approach. The warehousing approach represents the current stateof-the-art. In the warehousing approach, processing of sensor queries and access to the sensor network are separated.  (The sensor network is simply used by a data 
collection mechanism.) The warehousing approach proceeds in two steps. First, data is extracted from the sensor network in a predefined way and is stored in a database located on a unique front-end server. Subsequently, query processing takes place on the centralized database. The warehousing approach is well suited for answering predefined queries over historical data. The distributed approach has been described in [2][3] and is the focus of this paper. In the distributed approach, the query workload determines the data that should be extracted from sensors. The distributed approach is thus flexible – different queries extract different data from the sensor network – and efficient – only relevant data are extracted from the sensor network.  In addition, the distributed approach allows the sensor database system to leverage the computing resources on the sensor nodes: a sensor query can be evaluated at the front-end server, in the sensor network, at the sensors, or at some combination of the three.  In this paper, we describe the design space for a sensor database system and present the choices we have made in the implementation of the Cornell COUGAR system. This paper makes the following contributions: 1. We build on the results of Seshadri et al. [19] to define a data model and longrunning queries semantics for sensor databases. A sensor database mixes stored data and sensor data. Stored data are represented as relations while sensor data are represented as time series. Each long-running query defines a persistent view, which is maintained during a given time interval.  2. We describe the design and implementation of the Cornell COUGAR sensor database system. COUGAR extends the Cornell PREDATOR object-relational database system. In COUGAR, each type of sensor is modeled as a new Abstract Data Type (ADT). Signal-processing functions are modeled as ADT functions that return sensor data. Long-running queries are formulated in SQL with little modifications to the language. To support the evaluation of long-running queries, we extended the query execution engine with a new mechanism for the execution of sensor ADT functions. The initial version of this system has been demonstrated at the Intel Computing Continuum Conference [7].  Addressing these issues is a necessary first step towards a sensor database system. In addition, a sensor database system should account for sensor and communication failures; it should consider sensor data as measurements with an associated uncertainty not as facts; finally, it should be able to establish and run a distributed query execution plan without assuming global knowledge of the sensor network. We believe that these challenging issues can only be addressed once the data model and internal representation issues have been solved.  
