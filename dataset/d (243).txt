Queries in TinyDB, as in SQL, consist of a SELECT-FROM-WHERE clause supporting selection, join, projection, and aggregation. We also include explicit support for sampling, windowing, and sub-queries via materialization points. As is the case in the Cougar and TAG systems [36, 31], we view sensor data as a single table with one column per sensor type. Tuples are appended to this table periodically, at well
3Our query language includes a number of other unusual features tailored to the sensor network domain, such as the ability to log data for later of?ine delivery and the ability to actuate physical hardware in response to a query, which we will not discuss here.
de?ned sample intervals that are a parameter of the query. The period of time between each sample interval is known as an epoch. As we discuss in Section 6, epochs provide a convenient mechanism for structuring computation to minimize power consumption. Consider the query: SELECT nodeid, light, temp FROM sensors SAMPLE INTERVAL 1s FOR 10s
This query speci?es that each sensor should report its own id, light, and temperature readings (contained in the virtual table sensors) once per second for 10 seconds. Results of this query stream to the root of the network in an online fashion, via the multi-hop topology, where they may be logged or output to the user. The output consists of an evergrowing sequence of tuples, clustered into 1s time intervals. Each tuple includes a time stamp corresponding to the time it was produced.
Note that the sensors table is (conceptually) an unbounded, continuous data stream of values; as is the case in other streaming and online systems, certain blocking operations (such as sort and symmetric join) are not allowed over such streams unless a bounded subset of the stream, or window, is speci?ed. Windows in TinyDB are de?ned as ?xed-size materialization points over the sensor streams. Such materialization points accumulate a small buffer of data that may be used in other queries. Consider, as an example: CREATE STORAGE POINT recentlight SIZE 8 AS (SELECT nodeid, light FROM sensors SAMPLE INTERVAL 10s)
This statement provides a shared, local (i.e. single-node) location to store a streaming view of recent data similar to materialization points in other streaming systems like Aurora or STREAM [7, 34], or materialized views in conventional databases. Joins are allowed between two storage points on the same node, or between a storage point and the sensors relation, in which case sensors is used as the outer relation in a nested-loops join. That is, when a sensors tuple arrives, it is joined with tuples in the storage point at its time of arrival. This is effectively a landmark query [18] common in streaming systems. Consider, as an example: SELECT COUNT(*) FROM sensors AS s, recentLight AS rl WHERE rl.nodeid = s.nodeid AND s.light < rl.light SAMPLE INTERVAL 10s
This query outputs a stream of counts indicating the number of recent light readings (from 0 to 8 samples in the past) that were brighter than the current reading. In the event that a storage point and an outer query deliver data at different rates, a simple rate matching construct is provided that allows interpolation between successive samples (if the outer query is faster), or speci?cation of aggregation function to combine multiple rows (if the inner query is faster.) Space prevents a detailed description of this mechanism here.
TinyDB also includes support for grouped aggregation queries. Aggregation has the attractive property that it reduces the quantity of data that must be transmitted through the network; other sensor network research has noted that aggregation is perhaps the most common operation in the domain ([31, 25, 43]) - TinyDB includes a mechanism for user-de?ned aggregates and a metadata management system that supports optimizations over them, which we discuss in Section 4.1.
Paper under submission. Please do not distribute without permission. 4
In addition to aggregates over values produced during the same sample interval (for an example, as in the COUNT query above), users want to be able to perform temporal operations. For example, in a building monitoring system for conference rooms, users may detect occupancy by measuring maximum sound volume over time and reporting that volume periodically; for example, the query: SELECT WINAVG(volume, 30s, 5s) FROM sensors SAMPLE INTERVAL 1s
will report the average volume over the last 30 seconds once every 5 seconds, sampling once per second. This is an example of a slidingwindow query common in many streaming systems [34, 18].
When a query is issued in TinyDB, it is assigned an identi?er (id) that is returned to the issuer. This identi?er can be used to explicitly stop a query via a “STOP QUERY id” command. Alternatively, queries can be limited to run for a speci?c time period via a FOR clause (shown above,) or can include a stopping condition as an event (see below.)
