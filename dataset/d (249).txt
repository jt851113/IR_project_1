As a second example of the bene?t of power-aware optimization, we consider the optimization of the query: 
This query will cause an instance of the internal query (SELECT ...) to be started every time the event e occurs. The internal query samples results at every d seconds for a duration of k seconds, at which point it
stops running.
Note that, by the semantics formulated above, it is possible for multiple instances of the internal query to be running at the same time. If enough such queries are running simultaneously, the bene?t of eventbased queries (e.g. not having to poll for results) will be outweighed by the fact that each instance of the query consumes signi?cant energy sampling and delivering (independent) results. To alleviate the burden of running multiple copies of the same identical query , we employ a multi-query optimization technique based on rewriting. To do this, we convert external events (of type e) into a stream of events, and rewrite the entire set of independent internal queries as a sliding window join between events and sensors, with a window size of k seconds on the event stream, and no window on the sensor stream. For example: 
We execute this query by treating it as a join between a materialization point of size k on events and the sensors stream. When an event tuple arrives, it is added to the buffer of events. When a sensor tuple s arrives, events older than k seconds are dropped from the buffer and s is joined with the remaining events.
The advantage of this approach is that only one query runs at a time no matter how frequently the events of type e are triggered. This offers a large potential savings in sampling and transmission cost. At ?rst it might seem as though requiring the sensors to be sampled every d seconds irrespective of the contents of the event buffer would be prohibitively expensive. However, the check to see if the the event buffer is empty can be pushed before the sampling of the sensors, and can be done relatively quickly.
Figure 5 shows the power tradeoff for event-based queries that have and have not been rewritten. Rewritten queries are labeled as stream join and non-rewritten queries as asynch events. We measure the cost in mW of the two approaches using a numerical model of power costs for idling, sampling and processing (including the cost to check if the event queue is non-empty in the event-join case), but excluding transmission costs to avoid complications of modeling differences in cardinalities between the two approaches. We expect that the asynchronous approach will generally transmit many more results. We varied the sample rate and duration of the inner query, and the frequency of events. We chose the speci?c parameters in this plot to demonstrate query optimization tradeoffs; for much faster or slower event rates, one approach tends to always be preferable.
For very low event rates (fewer than 1 per second), the asynchronous events approach is sometimes preferable due to the extra overhead of empty-checks on the event queue in the stream-join case. However, for faster event rates, the power cost of this approach increases rapidly as independent samples are acquired for each event that few seconds. Increasing the duration of the inner query increases the cost of the asynchronous approach as more queries will be running simultaneously. The maximum absolute difference (of about .8mW) is roughly comparable to 1/4 the power cost of the CPU or radio.
Finally, we note that there is a subtle semantic change introduced by this rewriting. The initial formulation of the query caused samples in each of the internal queries to be produced relative to the time that the event ?red: for example, if event e1 ?red at time t, samples would appear at time t + d,t + 2d,.... If a later event e2 ?red at time t + i, it would produce a different set of samples at time t+i+d,t+i+2d,.... Thus, unless i were equal to d (i.e. the events were in phase), samples for the two queries would be offset from each other by up to d seconds. In the rewritten version of the query, there is only one stream of sensor tuples which is shared by all events.
In many cases, users may not care that tuples are out of phase with events. In some situations, however, phase may be very important. In such situations, one way the system could improve the phase accuracy of samples while still rewriting multiple event queries into a single join is via oversampling, or acquiring some number of (additional) samples every d seconds. The increased phase accuracy of oversampling comes at an increased cost of acquiring additional samples (which may still be less than running multiple queries simultaneously.) For now, we simply allow the user to specify that a query must be phase-aligned by specifying ON ALIGNED EVENT in the event clause.
Thus, we have shown that there are several interesting optimization issues in ACQP systems; ?rst, the system must properly order sampling, selection, and aggregation to be truly low power. Second, for frequent event-based queries, rewriting them as a join between an event stream and the sensors stream can signi?cantly reduce the rate at which a sensor must acquire samples.
