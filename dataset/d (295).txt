In COUGAR, signal-processing functions are represented as Abstract Data Type (ADT) functions. Today’s object-relational databases support Abstract Data Types that provide controlled access to encapsulated data through a well-defined set of functions [20]. We define a Sensor ADT for all sensors of a same type (e.g., temperature sensors, seismic sensors). The public interface of a Sensor ADT corresponds to the specific signal-processing functions supported by a type of sensor. An ADT object in the database corresponds to a physical sensor in the real world.  Signal-processing functions are modeled as scalar functions. Repeated outputs of an active signal processing functions are not explicitly modeled as sequences but as the result of successive executions of a scalar function during the span of a longrunning query. This decision induced some limitation. Indeed, as we will see below, queries containing explicit time constraints (such as aggregates over time windows) cannot be expressed. Sensor queries are formulated in SQL with little modifications to the language. The ‘FROM’ clause of a sensor query includes a relation whose schema contains a sensor ADT attribute (i.e., a collection of sensors). Expressions over sensor ADTs can be included in the ‘SELECT’ or in the ‘WHERE’ clause of a sensor query.  The queries we introduced in Section 1 are formulated in COUGAR as follows. The simplified schema of the sensor database contains one relation R(loc point, floor int, s sensorNode), where loc is a point ADT that stores the coordinates of the sensor, floor is the floor where the sensor is located in the data warehouse and sensorNode is a Sensor ADT that supports the methods getTemp() and detectAlarmTemp(threshold), where threshold is the threshold temperature above which abnormal temperatures are returned. Both ADT functions return temperature represented as float. ‧ Query 1: “Return repeatedly the abnormal temperatures measured by all sensors” SELECT R.s.detectAlarmTemp(100) FROM R WHERE $every(); The expression $every() is introduced as a syntactical construct to indicate that the query is long-running.  ‧ Query 2: “Every minute, return the temperature measured by all sensors on the third floor”. SELECT R.s.getTemp() FROM  R WHERE R.floor = 3 AND $every(60); The expression $every() takes as argument the time in seconds between successive outputs of the sensor ADT functions in the query. ‧ Query3: “Generate a notification whenever two sensors within 5 yards of each other measure simultaneously an abnormal temperature”.  
SELECT R1s.detectAlarmTemp(100), R2.s. detectAlarmTemp (100) FROM R R1, R R2 WHERE $SQRT($SQR(R1.loc.x – R2.loc.x) + $SQR( R1.loc.y – R2.loc.y)) < 5        AND R1.s > R2.s AND $every(); This formulation assumes that the system incorporates an equality condition on the time at which the temperatures are obtained from both sensors.  Query 4 and Query 5 cannot be expressed in our initial version of COUGAR because aggregates over time windows are not supported.  In COUGAR, the time interval associated with long-running queries is the interval between the instant the query is submitted and the instant the query is explicitly stopped.  
