The long-range vision for sensor networks is that they will be deployed in very large quantities – somewhere between many thousands and billions, depending on the prognostication. This scale requires that the programming and and deployment of these devices be extremely simple, and amenable to signi?cant adaptivity in the ?eld. Networking researchers have focused on routing and network scheduling issues in this regard. An open question, however, is how collections of these sensors can be programmed or “tasked” to perform a family of different behaviors. There are a number of approaches suggested for this problem, some of which are based on database languages. First, we note that Turing-complete sensor programming languages are unlikely to be widely used. Sensor programming entails simultaneously dealing with the challenges of distributed and embedded programming. Both are dif?cult; the multiplication of the dif?culties is prohibitive for all but a small number of experts. As one set of alternatives, various parties have proposed declarative query languages for sensor networks. There are two main approaches currently being advocated. The ?rst installs an independent query at each node, with the multiple query instances working together to achieve some goal; Directed Diffusion [32] is the best-known example of this idea. The second approach uses SQL-style, collective querying of the entire sensor network as a single streaming database [50, 36]. Both of these approaches shield the user from execution details, but they differ in their degree of abstraction. The per-node diffusion approach requires users to reason about the interactions of multiple query instances, while the collective query approach lets users state their overall semantics on a high-level task for the entire sensor ?eld. The collective approach also allows for various cross-node optimizations that have been the subject of recent research [36, 37]. Our own TinyDB work is a collective query model. It is being shipped by Crossbow, the commercial vendor of the Berkeley motes, largely because they believe the programming interface to be more broadly appealing than programming TinyOS directly.
While the streaming database metaphor is a rosy story for many scenarios, we note that some natural sensor tasks are dif?cult to express declaratively. For example, vehicle tracking is an inherently localized task. The current TinyDB approach to tracking is based on active database rules [27], which look more like diffusion than collective queries. Rule programming is notoriously tricky when scaling beyond a handful of interacting rules. An alternative to a declarative, calculus-based language is an algebraic, data?ow language. This could be used both in per-node or collective metaphors, and is equally amenable to automatic logical optimization. More ?exible yet would be a generic “boxes-and-arrows” data?ow language over arbitrary code modules developed in a low-level language. This is the approach taken by various data analysis and visualization tools in the scienti?c and ?nancial data mining domains (e.g. [31, 47], etc.) If the semantics of the modules are arbitrary, opportunities for automatic optimization become limited. Of course, some extensible middle ground is also possible for both declarative and algebraic languages; TinyDB’s language supports user-de?ned aggregates and scalar functions, for example, with extensibility APIs enabling various optimizations [36].
