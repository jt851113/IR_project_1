Each node in TinyDB maintains a catalog of metadata that describes its local attributes, events, and user-de?ned functions. This metadata is periodically copied to the root of the network for use by the optimizer.
Metadata are registered with the system via static linking done at compile time using the TinyOS C-like programming language. Events and attributes pertaining to various operating system and TinyDB components are made available to queries by declaring them in an interface ?le and providing a small handler function. For example, in order to expose network topology to the query processor, the TinyOS Network component de?nes the attribute parent of type integer and registers a handler that returns the id of the node’s parent in the current routing tree.
Event metadata consists of a name, a signature, and a frequency estimate that is used in query optimization (see Section 4.3 below.) Userde?ned predicates also have a name and a signature, along with a selectivity estimate which is provided by the author of the function.
Table 2 summarizes the metadata associated with each attribute, along with a brief description. Attribute metadata is used primarily in two contexts: information about the cost, time to fetch, and range of an attribute is used in query optimization, while information about the semantic properties of attributes is used in query dissemination and result processing. Table 3 gives examples of power and sample time values for some actual sensors – notice that the power consumption and time to sample can differ across sensors by several orders of magnitude.
The catalog also contains metadata about TinyDB’s extensible aggregate system. As with other extensible database systems [39] the catalog includes names of aggregates and pointers to their code. Each aggregate consists of a triplet of functions, that initialize, merge, and update the ?nal value of partial aggregate records as they ?ow through the system. As in the TAG[31] system, aggregate authors must provide information about functional properties. In TinyDB, we currently require two: whether the aggregate is monotonic and whether it is exemplary or summary. COUNT is a monotonic aggregate as its value can only get larger as more values are aggregated. MIN is an exemplary aggregate, as it returns a single value from the set of aggregate values, while AVERAGE is a summary aggregate because it computes some property over the entire set of values.
TinyDB also stores metadata information about the costs of processing and delivering data, which is used in query-lifetime estimation. The costs of these phases in TinyDB were shown in Figure 2 – they range from 2 mA while sleeping, to over 20 mA while transmitting and processing. Note that actual costs vary from mote to mote – for example, with a small sample of 5 motes (using the same batteries), we found that the average current with processor active varied from 13.9 to 17.6 mA (with the average being 15.66 mA).