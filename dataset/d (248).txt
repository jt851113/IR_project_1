Having described the metadata maintained by TinyDB, we now describe how it is used in query optimization.
As Table 3 shows, sampling is often an expensive operation in terms of power. However, a sample from a sensor s must be taken to evaluate any predicate over the attribute sensors.s. If a predicate discards a tuple of the sensors table, then subsequent predicates need not examine the tuple – and hence the expense of sampling any attributes referenced in those subsequent predicates can be avoided. Thus these predicates are “expensive”, and need to be ordered carefully. The predicate ordering problem here is somewhat different than than in the earlier literature (e.g. [20]) because (a) an attribute may be referenced in multiple predicates, and (b) expensive predicates are only on a single table, sensors. The ?rst point introduces some subtlety, as it is not clear which predicate should be “charged” the cost of the sample.

To model this issue, we treat the sampling of a sensor t as a separate “job” τ to be scheduled along with the predicates. Hence a set of predicates P = {p1,...,pm} is rewritten as a set of operations S = {s1,...,sn}, where P ? S, and  = {τ1,...,τn-m} contains one sampling operator for each distinct attribute referenced in P. The selectivity of sampling operators is always 1. The selectivity of selection operators is derived by assuming attributes have a uniform distribution over their range (which is available in the catalog.) Relaxing this assumption by, for example, storing histograms or timedependent functions per-attribute remains an area of future work. The cost of an operator (predicate or sample) can be determined by consulting the metadata, as described in the previous section. In the cases we discuss here, selections and joins are essentially “free” compared to sampling, but this is not a requirement of our technique.
We also introduce a partial order on S, where τi must precede pj if pj references the attribute sampled by τi. The combination of sampling operators and the dependency of predicates on samples captures the costs of sampling operators and the sharing of operators across predicates.
The partial order induced on S forms a graph with edges from sampling operators to predicates. This is a simple series-parallel graph. An optimal ordering of jobs with series-parallel constraints is a topic treated in the Operations Research literature that inspired earlier optimization work [23, 28, 20]; Monma and Sidney present the Series-Parallel Algorithm Using Parallel Chains [33], which gives an optimal ordering of the jobs in O(|S|log|S|) time. Due to space constraints, we have glossed over the details of handling the expensive nature of sampling in the SELECT, GROUP BY, and HAVING clauses. The basic idea is to add them to S with appropri-ate selectivities, costs, and ordering constraints.
As an example of this process, consider the query: 
The order of magnitude difference in per-sample costs for the accelerometer and magnetometer suggests that the power costs of plans with different orders of sampling and selection will vary substantially. We consider three possible plans: in the ?rst, the magnetometer and accelerometer are sampled before either selection is applied. In the second, the magnetometer is sampled and the selection over its reading (which we call Smag) is applied before the accelerometer is sampled or ?ltered. In the third plan, the accelerometer is sampled ?rst and its selection (Saccel) is applied before the magnetometer is sampled. We compared the cost of these three plans, and, as expected, found that the ?rst was always more expensive than the other two. More interestingly, the second can be an order of magnitude more expensive than third, when Saccel is much more selective than Smag. Conversely, when Smag is highly selective, it can be cheaper to sample the magnetometer ?rst, although only by a small factor (.8). The order of magnitude difference in relative costs represents an absolute difference of 1320 uJ per sample, or 3.96 mW at a (slow) sample rate of one sample per second – putting the additional power consumption from sampling in the incorrect order on par with the power costs of running the radio or CPU for an entire second.
Similarly, we note that there are certain kinds of aggregate functions where the same kind of interleaving of sampling and processing can also lead to a performance savings. Consider the query: 
In this query, the maximum of eight seconds worth of light readings will be computed, but only light readings from sensors whose magentometers read greater than x will be considered. Interestingly, it turns out that, unless the x predicate is very selective, it will be cheaper to evaluate this query by checking to see if each new light reading is greater than the previous reading and then applying the selection predicate over mag, rather than ?rst sampling mag. This sort of reordering, which we call exemplary aggregate pushdown can be applied to any exemplary aggregate (e.g. MIN, MAX). Unfortunately, the selectivities of exemplary aggregates are very hard to capture, especially for window aggregates. We reserve the problem of ordering exemplary aggregates in query optimization for future work.