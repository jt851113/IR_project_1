We ran each algorithm described in Section 3 on each of
the 96 randomly generated profiles and normalized the results
by specifying each algorithmâ€™s score as a percentage
of the score generated by GREEDY. Then for each profile
class, we averaged the normalized scores for the four profiles
from that class. The results are shown in Table 3. Note
that because of normalization, an algorithm does better than
GREEDY when its score is more than 100.
From Table 3, we can see that GREEDY produced the
highest value caches for 14 of the 24 profile classes. SA
produced the highest valued caches for the remaining 10
classes. Therefore, the simplest and fastest algorithm8 was
also the most effective, dispelling the notion that expressive
profiles require complex processing to be effectively
used. As can be seen in Table 3, SA beat GREEDY when the
profiles processed were predominantly composed of appreciating
utility equations (Table 3c and d). In fact, SA beat
GREEDY in 10 of the 12 profile classes of this form. SA did
especially well when  was small, producing the best cache
for all 6 classes of appreciating profiles with .
SAâ€™s relative success with appreciating profiles can be
explained as follows. GREEDY, by nature, performs no
lookahead and thus it will never choose to place an object
from a low-valued domain in the cache, even if objects from
that domain can become more valuable as the cache gets
filled with more objects. But for appreciating profiles, the
best caches will often be those that contain objects from domains
that initially have low value, but that increase in value
as more of them are put into the cache. Whereas GREEDY
will never choose these low-valued objects, with some nonzero
probability, SA will select a random cache that includes
enough of these low-valued objects that they take
on a higher value. When  is small, the number of objects
required to be in the cache before these objects increase in
value is also small, and the probability of randomly choosing
a cache with  of these objects increases. Hence, SA
consistently produces better quality caches than GREEDY
when  is small and utility equations are predominantly appreciating.
It should be pointed out that GREEDYâ€™s poor
performance with profiles with appreciating utility equations
also had to do with the way we chose random values
for  and 
 . For both appreciating and depreciating utility
equations, we first chose a random value between 50 and
100, and this became the value of what was supposed to be
the larger of  and 
 for depreciating equations and 
for appreciating equations). The value of the smaller vari-
able was then calculated using the ratio,  , set by the profile
class. Therefore, for appreciating utility equations such that
 ,  is never greater than 10, and for appreciating
utility equations such that  )Â±c/ ,  is never greater than
50. Given that values for flat utility equations were random
values between 0 and 100, with high probability the values
for these objects were greater than , and therefore, these
objects were far more likely to be chosen by GREEDY.
  It is also interesting to note the poor performance of
Branch-and-bound (BnB), having the lowest scores for 20
of the 24 profile classes. BnB does poorly at profile-driven
prefetching because it doesnâ€™t scale: the search tree that the
algorithm has to traverse has a height of 20 (one level per
domain), and a degree of 640 (one per object in the candidate
set belonging to any given domain). Therefore, the
search tree consists of 1I nodes! After 10 minutes (at
which point we cut off its search), BnB was never left with
a cache with objects from more than 3 domains. Therefore,
we did not include BnB in