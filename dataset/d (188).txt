Given our basic syntax and structure of aggregates, an obvious question remains: what aggregate functions can be expressed in TAG? The original SQL specifcation offers just ?ve options: COUNT, MIN, MAX, SUM, and AVERAGE. Although these basic functions are suitable for a wide range of database applications, we did not wish to constrain TAG to only these choices. For this reason, we present a general classification of aggregate functions and show how the dimensions of that classification affect the performance of TAG throughout the paper. We will assume that when aggregation functions are registered with TAG, they are classified along the dimensions described below.3
3We omit a detailed discussion of how new aggregate functions are registered with motes. For now, aggregates are pre-compiled into motes. Virtual-machine languages recently proposed for TinyOS-style [16] motes could also be used for this purpose.
We classify aggregates according to four properties that are particularly important to sensor networks. Table 1 shows how specific aggregation functions can be classified according to these properties, and indicates the sections of the paper where the various dimensions of the classification are emphasized.
The various dimension is duplicate sensitivity. Duplicate insensitive aggregates are unaffected by duplicate readings from a single device while duplicate sensitive aggregates will change when a duplicate reading is reported. Duplicate sensitivity implies restrictions on network properties and on certain optimizations, as described in Section 7.5.
Second, exemplary aggregates return one or more representative values from the set of all values; summary aggregates compute some property over all values. This distinction is important because exemplary aggregates behave unpredictably in the face of loss, and, for the same reason, are not amenable to sampling. Conversely, for summary aggregates, the aggregateapplied to a subset can be treated as a robust approximation of the true aggregate value, assuming that either the subset is chosen randomly, or that the correlations in the subset can be accounted for in the approximation logic.
The fourth dimension relates to the amount of state required for each partial state record. For example, a partial AVERAGE record consists of a pair of values, while a partial COUNT record constitutes only a single value. Though TAG correctly computes any aggregate that conforms to the speci?cation of  in Section 3 above, its performance is inversely related to the amount of intermediate state required per aggregate. The ?rst three categories of this dimension (e.g. distributive, algebraic, holistic) were initially presented in work on data-cubes [9].
In Distributive aggregates, the partial state is simply the aggregate for the partition of data over which they are computed. Hence the size of the partial state records
is the same as the size of the ?nal aggregate.

In Algebraic aggregates, the partial state records are not themselves aggregates for the partitions, but are of constant size.

In Holistic aggregates,the partial state records are proportional in size to the set of data in the partition. In essence, for holistic aggregates no useful partial aggregation can be done, and all the data must be brought together to be aggregated by the evaluator.

Unique aggregates are similar to holistic aggregates, except that the amount of state that must be propagated is proportional to the number of distinct values in the partition.

In Content-Sensitive aggregates, the partial state records are proportional in size to some (perhaps statistical) property of the data values in the partition. Many approximate aggregates proposed recently in the database literature are content-sensitive. Examples of such aggregates include ?xed-width histograms, wavelets, and so on; see [3] for an overview of such functions.
In summary, we have classified aggregates according to their state requirements, tolerance of loss, duplicate sensitivity, and monotonicity. We will refer back to this classification throughout the text, as these properties will determine the applicability of communication optimizations we present later. Understanding how aggregates ?t into these categories is a cross-cutting issue that is critical (and useful) in many aspects of sensor data collection.
Note that our formulation of aggregate functions, combined with this taxonomy,is ?exible enoughto encompass a wide range of sophisticated operations. For example, we have implemented (in the simulator described in Section 5 below), an isobar ?nding aggregate. This is a duplicateinsensitive, summary,monotonic,content-sensitiveaggregate that builds a topological map representing discrete bands of one attribute (light, for example) plotted against two other attributes (x and y position in some local coordinate space, for example.)
4The HISTOGRAM aggregate sorts sensor readings into ?xed-width buckets and returns the size of each bucket; it is content-sensitive because the number of buckets varies depending on how widely spaced sensor readings are. 5COUNT DISTINCT returns the number of distinct values reported across all motes.